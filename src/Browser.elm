module Browser exposing
  ( staticPage
  , sandbox
  , embed
  , fullscreen
  , View
  , Env
  , Url
  , load
  , reload
  , reloadAndSkipCache
  )

{-|

# Static Pages
@docs staticPage

# Dynamic Pages
@docs sandbox, embed, fullscreen, View, Env, Url

# Page Loads
@docs load, reload, reloadAndSkipCache

-}


import Browser.History.Manager as History
import Elm.Kernel.Browser
import Task exposing (Task)
import VirtualDom



-- PROGRAMS


{-| Show some static HTML.

    import Browser exposing (staticPage)
    import Html exposing (text)

    main =
      staticPage (text "Hello!")

Using `staticPage` means that all user input is ignored. For example, the
events generated by button presses are sent to a black hole of nothingness,
never to be heard from again. Try out [`sandbox`](#sandbox) to make an
interactive Elm program!
-}
staticPage : VirtualDom.Node msg -> Program () () msg
staticPage =
  Elm.Kernel.Browser.staticPage


{-| Create a “sandboxed” program that cannot communicate with the outside
world.

This is great for learning the basics of [The Elm Architecture][tea]. You can
see sandboxes in action in tho following examples:

  - [Buttons](http://elm-lang.org/examples/buttons)
  - [Text Field](http://elm-lang.org/examples/field)
  - [Checkboxes](http://elm-lang.org/examples/checkboxes)

Those are nice, but **I very highly recommend reading [this guide][guide]
straight through** to really learn how Elm works. Understanding the
fundamentals actually pays off in this language!

[tea]: https://guide.elm-lang.org/architecture/
[guide]: https://guide.elm-lang.org/
-}
sandbox :
  { init : model
  , view : model -> VirtualDom.Node msg
  , update : msg -> model -> model
  }
  -> Program () model msg
sandbox { init, view, update } =
  embed
    { init = \_ -> ( init, Cmd.none )
    , view = view
    , update = \msg model -> ( update msg model, Cmd.none )
    , subscriptions = \_ -> Sub.none
    }


{-| Create a program that can be embedded in a larger JavaScript project.
This is a great low-risk way of introducing Elm into your existing work, and
lots of companies that use Elm started with this approach!

Unlike a [`sandbox`](#sandbox), an “embedded” program can talk to the outside
world in a couple ways:

  - `Cmd` &mdash; you can “command” the Elm runtime to do stuff, like HTTP.
  - `Sub` &mdash` you can “subscribe” to event sources, like clock ticks.
  - `flags` &mdash; JavaScript can pass in data when starting the Elm program
  - `ports` &mdash; set up a client-server relationship with JavaScript

As you read [the guide][guide] you will run into a bunch of examples of `embed`
in [this section][fx]. You can learn more about flags and ports in [the interop
section][interop].

[guide]: https://guide.elm-lang.org/
[fx]: https://guide.elm-lang.org/architecture/effects/
[interop]: https://guide.elm-lang.org/interop/
-}
embed :
  { init : flags -> (model, Cmd msg)
  , view : model -> VirtualDom.Node msg
  , update : msg -> model -> ( model, Cmd msg )
  , subscriptions : model -> Sub msg
  }
  -> Program flags model msg
embed =
  Elm.Kernel.Browser.embed


{-| Create a fullscreen Elm program. This expands the functionality of
[`embed`](#embed) in two important ways:

  1. The `view` gives you control over the `<title>` and `<body>`.

  2. The `onNavigation` field lets you capture URL changes. This
  allows you to create single-page apps (SPAs) with the help of the
  [`Browser.History`](Browser-History) module.

You also get an [`Env`](#Env) value on `init` which gives a bit more
information about the host browser.

Here are some example usages of `fullscreen` programs:

  - [RealWorld example app](https://github.com/rtfeldman/elm-spa-example)
  - [Elm’s package website](https://github.com/elm-lang/package.elm-lang.org)

These are quite advanced Elm programs, so be sure to go through [the
guide](https://guide.elm-lang.org/) first to get a solid conceptual foundation
before diving in! If you start reading a calculus book from page 314, it might
seem confusing. Same here!
-}
fullscreen :
  { init : Env flags -> (model, Cmd msg)
  , view : model -> View msg
  , update : msg -> model -> ( model, Cmd msg )
  , onNavigation : Maybe (Url -> msg)
  , subscriptions : model -> Sub msg
  }
  -> Program flags model msg
fullscreen impl =
  Elm.Kernel.Browser.fullscreen <|
    case impl.onNavigation of
      Nothing ->
        impl

      Just toMsg ->
        { impl | subscriptions = History.addListen toMsg impl.subscriptions }


{-| This data specifies the `<title>` and all of the nodes that should go in
the `<body>`. This means you can update the title as people navigate through
your single-page app.
-}
type alias View msg =
  { title : String
  , body : List (VirtualDom.Node msg)
  }



-- ENVIRONMENT


{-| When you initialize an Elm program, you get some information about the
environment. Right now this contains:

  - `url` &mdash; The initial [`Url`](#Url) of the page. If you are creating
  a single-page app (SPA) you need this information to figure out what to show
  on screen! If you are not making an SPA, you can ignore this.

  - `flags` &mdash; This holds data that is passed in from JavaScript.
-}
type alias Env flags =
  { url : Url
  , flags : flags
  }



-- URL


{-| A bunch of information about the URL in the address bar. You should always
be using the [`elm-lang/url`][url] package to turn these URLs into nice Elm
data. Check out the [`Url.Parser`][parser] module in particular.

[url]: http://package.elm-lang.org/packages/elm-lang/url/latest
[parser]: http://package.elm-lang.org/packages/elm-lang/url/latest/Url-Parser

**Note:** The fields correspond with the fields in `document.location` as
described [here](https://developer.mozilla.org/en-US/docs/Web/API/Url).
-}
type alias Url =
  { href : String
  , host : String
  , hostname : String
  , protocol : String
  , origin : String
  , port_ : String
  , pathname : String
  , search : String
  , hash : String
  , username : String
  , password : String
  }



-- PAGE LOADS


{-| Leave the current page and load the given URL. **This always results in a
page load**, even if the provided URL is the same as the current one.

    load "http://elm-lang.org"

Check out the [`elm-lang/url`][url] package for help building URLs. The
[`Url.absolute`][abs] and [`Url.relative`][rel] functions can be particularly
handy!

Check out the [`Browser.History`](Browser-History) module if you want
page transitions that are faster and prettier, like in a “single-page app”.

[url]: http://package.elm-lang.org/packages/elm-lang/url/latest
[abs]: http://package.elm-lang.org/packages/elm-lang/url/latest/Url#absolute
[rel]: http://package.elm-lang.org/packages/elm-lang/url/latest/Url#relative

-}
load : String -> Task Never Never
load =
  Elm.Kernel.Browser.load


{-| Reload the current page. **This always results in a page load!**
This may grab resources from the browser cache, so use
[`reloadAndSkipCache`](#reloadAndSkipCache)
if you want to be sure that you are not loading any cached resources.
-}
reload : Task Never Never
reload =
  Elm.Kernel.Browser.reload False


{-| Reload the current page without using the browser cache. **This always
results in a page load!** It is more common to want [`reload`](#reload).
-}
reloadAndSkipCache : Task Never Never
reloadAndSkipCache =
  Elm.Kernel.Browser.reload True
